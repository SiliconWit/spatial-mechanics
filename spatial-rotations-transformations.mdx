---
title: "Lesson 3: 3D Rotation Matrices and Spatial Transformations"
description: "3D rotation matrices, Euler angles, arbitrary axis rotations (decomposition and Rodrigues methods), and homogeneous transformations for robotics and aerospace applications"
contributors: "sam-macharia,jack-kojiro"
pubDate: 2025-11-21
tags: ["spatial-mechanics", "3d-rotations", "euler-angles", "rodrigues-formula", "rotation-matrices", "homogeneous-transformations", "gimbal-lock"]
excerpt: "Explore 3D rotation mathematics: coordinate axis rotations, Euler angle sequences with singularity management, arbitrary axis rotations using decomposition and Rodrigues methods, and 4√ó4 homogeneous transformations for unified spatial motion."
---

import SpatialMechanicsComments from '../../../../components/spatial-mechanics/SpatialMechanicsComments.astro';
import TawkWidget from '../../../../components/TawkWidget.astro';
import UniversalContentContributors from '../../../../components/UniversalContentContributors.astro';
import Copyright from '../../../../components/Copyright.astro';
import BionicText from '../../../../components/BionicText.astro';
import TailwindWrapper from '../../../../components/TailwindWrapper.jsx';
import { Tabs, TabItem } from '@astrojs/starlight/components';
import { Card, CardGrid, Badge, Steps, LinkButton } from '@astrojs/starlight/components';

<UniversalContentContributors 
  contributors={frontmatter.contributors}
/>

Learn 3D rotation mathematics through coordinate axis rotations, Euler angles, arbitrary axis methods (decomposition and Rodrigues formula), and homogeneous transformations applied to robotic welding, drone gimbals, and satellite attitude control.

## üéØ Learning Objectives

By the end of this lesson, you will be able to:

1. **Construct** <Badge text="rotation matrices" variant="caution" /> for rotations about <Badge text="coordinate axes" variant="tip" /> and <Badge text="arbitrary vectors" variant="note" />
2. **Apply** <Badge text="Euler angle sequences" variant="caution" /> for systematic <Badge text="3D orientation" variant="tip" /> representation
3. **Compose** <Badge text="4√ó4 homogeneous transformation matrices" variant="caution" /> for <Badge text="unified spatial motion" variant="tip" />
4. **Analyze** <Badge text="transformation sequences" variant="caution" /> understanding <Badge text="order-dependent composition" variant="tip" />

## üîß Real-World Engineering Challenge: 3D Spatial Orientation Control

<BionicText method="advanced" intensity="medium" class="highlight">
Spatial orientation control is fundamental across robotics, aerospace, computer graphics, and automation. From industrial robots manipulating parts with precise tool angles, to spacecraft maintaining attitude in orbit, to animation systems rotating 3D models - all require mathematical frameworks for representing and composing 3D rotations and transformations.
</BionicText>

### Representative Systems

**3D Spatial Control Applications:**
- **Industrial Robots** (6-DOF manipulators) - tool orientation for welding, machining, assembly
- **Aerospace Systems** (satellites, aircraft) - attitude control and orientation tracking
- **Computer Graphics** (animation, CAD) - 3D object rotation and camera positioning
- **Motion Capture Systems** (biomechanics, VR) - tracking 3D body segment orientations
- **Coordinate Measuring Machines** (CMMs) - probe orientation for complex surface inspection
- **Gimbals and Stabilizers** (cameras, sensors) - maintaining orientation despite platform motion

### The 3D Rotation Challenge

These systems require precise control of:

:::note[Critical 3D Orientation Requirements]
- **Orientation representation** using rotation matrices, Euler angles, or quaternions
- **Composition of rotations** understanding order-dependent matrix multiplication
- **Singularity management** avoiding gimbal lock and numerical instabilities
- **Coordinate frame transformations** relating multiple reference frames systematically
- **Smooth orientation interpolation** for continuous motion and animation
:::

> **Engineering Question:** How do we mathematically represent and compose complex 3D orientations in a systematic way that handles singularities and works across diverse applications?

### Why 3D Spatial Mathematics Matters

**Consequences of Poor Mathematical Foundation:**
- **Orientation errors** from incorrect rotation sequences or coordinate confusion
- **Gimbal lock** causing loss of degrees of freedom at singular configurations
- **Numerical instability** from poorly conditioned transformations
- **Programming complexity** without systematic transformation framework
- **Limited scalability** to more complex multi-body or hierarchical systems

**Benefits of Systematic 3D Analysis:**
- **Precise orientation control** using robust mathematical representations
- **Predictable behavior** through systematic matrix composition rules
- **Singularity awareness** enabling detection and avoidance strategies
- **Unified framework** applicable across robotics, aerospace, and graphics
- **Foundation for advanced topics** (quaternions, screws, differential kinematics)

## üìö Fundamental Theory: 3D Rotation Mathematics

### Basic Rotation Matrices About Coordinate Axes

<BionicText method="advanced" intensity="medium" class="highlight">
3D rotations are more complex than 2D because rotation order matters and multiple representations exist. Basic rotations about coordinate axes provide the building blocks for all spatial orientations. Following the established axis convention where counterclockwise rotation is positive, we can derive rotation matrices for each coordinate axis. Each rotation transforms a mobile frame (A, B, C) relative to a fixed frame (X, Y, Z).
</BionicText>

<div style={{ display: 'flex', justifyContent: 'center', width: '100%' }}>
  <TailwindWrapper>
	![Axes Convention](https://pub-b1eb899abc464b5baf5b9521d163efd9.r2.dev/spatial-mechanics/axes-convention.svg)
  </TailwindWrapper>
</div>

<Tabs>
  <TabItem label="X-Axis Rotation">

    **Rotation about X-axis by angle Œ±:**

    <div style={{ display: 'flex', justifyContent: 'center', width: '100%' }}>
      <TailwindWrapper>
    	![Rotation about X Axis](https://pub-b1eb899abc464b5baf5b9521d163efd9.r2.dev/spatial-mechanics/rotation-about-x-axis.svg)
      </TailwindWrapper>
    </div>

    **Geometric Analysis:**

    After rotating axis B:
    $$
    \begin{aligned}
    \cos(\alpha) &= \frac{+y}{B} \quad \Rightarrow \quad b = B \cos(\alpha) \\
    \sin(\alpha) &= \frac{+z}{B} \quad \Rightarrow \quad c = B \sin(\alpha)
    \end{aligned}
    $$

    After rotating axis C:
    $$
    \begin{aligned}
    \cos(\alpha) &= \frac{+z}{C} \quad \Rightarrow \quad c = C \cos(\alpha) \\
    \sin(\alpha) &= \frac{-y}{C} \quad \Rightarrow \quad b = -C \sin(\alpha)
    \end{aligned}
    $$

    **Transformation Summary:**

    | Before | After |
    |--------|-------|
    | A(1,0,0) | A(1,0,0) |
    | B(0,1,0) | B(0, cos Œ±, sin Œ±) |
    | C(0,0,1) | C(0, -sin Œ±, cos Œ±) |

    <Card title="üîÑ X-Axis Rotation Matrix" icon="document">
    $$
    R_x(\alpha) = \begin{bmatrix}
    1 & 0 & 0 \\
    0 & \cos(\alpha) & -\sin(\alpha) \\
    0 & \sin(\alpha) & \cos(\alpha)
    \end{bmatrix}
    $$

    **Physical Meaning:** Rotation about X-axis corresponds to "roll" motion - like an aircraft banking left or right. Rotates vectors around the X-axis, leaving X-coordinates unchanged while rotating Y and Z components in the YZ-plane.
    </Card>

  </TabItem>
  <TabItem label="Y-Axis Rotation">

    **Rotation about Y-axis by angle Œ≤:**

    <div style={{ display: 'flex', justifyContent: 'center', width: '100%' }}>
      <TailwindWrapper>
    	![Rotation about Y Axis](https://pub-b1eb899abc464b5baf5b9521d163efd9.r2.dev/spatial-mechanics/rotation-about-y-axis.svg)
      </TailwindWrapper>
    </div>

    **Geometric Analysis:**

    After rotating axis A:
    $$
    \begin{aligned}
    \cos(\beta) &= \frac{+x}{A} \quad \Rightarrow \quad a = A \cos(\beta) \\
    \sin(\beta) &= \frac{-z}{A} \quad \Rightarrow \quad c = -A \sin(\beta)
    \end{aligned}
    $$

    After rotating axis C:
    $$
    \begin{aligned}
    \cos(\beta) &= \frac{+z}{C} \quad \Rightarrow \quad c = C \cos(\beta) \\
    \sin(\beta) &= \frac{+x}{C} \quad \Rightarrow \quad a = C \sin(\beta)
    \end{aligned}
    $$

    **Transformation Summary:**

    | Before | After |
    |--------|-------|
    | A(1,0,0) | A(cos Œ≤, 0, -sin Œ≤) |
    | B(0,1,0) | B(0,1,0) |
    | C(0,0,1) | C(sin Œ≤, 0, cos Œ≤) |

    <Card title="üîÑ Y-Axis Rotation Matrix" icon="document">
    $$
    R_y(\beta) = \begin{bmatrix}
    \cos(\beta) & 0 & \sin(\beta) \\
    0 & 1 & 0 \\
    -\sin(\beta) & 0 & \cos(\beta)
    \end{bmatrix}
    $$

    **Physical Meaning:** Rotation about Y-axis corresponds to "pitch" motion - like an aircraft nose up or down. Rotates vectors around the Y-axis, leaving Y-coordinates unchanged while rotating X and Z components in the XZ-plane.
    </Card>

  </TabItem>
  <TabItem label="Z-Axis Rotation">

    **Rotation about Z-axis by angle Œ≥:**

    <div style={{ display: 'flex', justifyContent: 'center', width: '100%' }}>
      <TailwindWrapper>
    	![Rotation about Z Axis](https://pub-b1eb899abc464b5baf5b9521d163efd9.r2.dev/spatial-mechanics/rotation-about-z-axis.svg)
      </TailwindWrapper>
    </div>

    **Geometric Analysis:**

    After rotating axis A:
    $$
    \begin{aligned}
    \cos(\gamma) &= \frac{+x}{A} \quad \Rightarrow \quad a = A \cos(\gamma) \\
    \sin(\gamma) &= \frac{+y}{A} \quad \Rightarrow \quad b = A \sin(\gamma)
    \end{aligned}
    $$

    After rotating axis B:
    $$
    \begin{aligned}
    \cos(\gamma) &= \frac{+y}{B} \quad \Rightarrow \quad b = B \cos(\gamma) \\
    \sin(\gamma) &= \frac{-x}{B} \quad \Rightarrow \quad a = -B \sin(\gamma)
    \end{aligned}
    $$

    **Transformation Summary:**

    | Before | After |
    |--------|-------|
    | A(1,0,0) | A(cos Œ≥, sin Œ≥, 0) |
    | B(0,1,0) | B(-sin Œ≥, cos Œ≥, 0) |
    | C(0,0,1) | C(0,0,1) |

    <Card title="üîÑ Z-Axis Rotation Matrix" icon="document">
    $$
    R_z(\gamma) = \begin{bmatrix}
    \cos(\gamma) & -\sin(\gamma) & 0 \\
    \sin(\gamma) & \cos(\gamma) & 0 \\
    0 & 0 & 1
    \end{bmatrix}
    $$

    **Physical Meaning:** Rotation about Z-axis corresponds to "yaw" motion - like an aircraft turning left or right. Rotates vectors around the Z-axis, leaving Z-coordinates unchanged while rotating X and Y components in the XY-plane.
    </Card>

  </TabItem>
</Tabs>

### Rotation Matrix Properties

<Card title="üìê Essential Rotation Matrix Properties" icon="document">
**Orthogonality:** $R^T R = I$ (columns are orthonormal vectors)
**Determinant:** $\det(R) = +1$ (proper rotations, no reflections)
**Inverse:** $R^{-1} = R^T$ (transpose equals inverse)
**Composition:** $R_3 R_2 R_1$ applies $R_1$ first, then $R_2$, then $R_3$

**Physical Meaning:** Rotation matrices preserve lengths and angles, representing pure rotations without scaling or reflection in 3D space.
</Card>

### 4√ó4 Homogeneous Transformation Matrices

<BionicText method="advanced" intensity="medium" class="highlight">
Extending the 2D homogeneous coordinate concept to 3D, we use 4√ó4 matrices to unify rotation and translation into a single mathematical operation. This powerful framework is the foundation for all modern robot kinematics and computer graphics.
</BionicText>

<Card title="üéØ Spatial Transformation Matrix" icon="document">
**General 4√ó4 transformation:**
$$T = \begin{bmatrix} R_{3√ó3} & \mathbf{t}_{3√ó1} \\ \mathbf{0}_{1√ó3} & 1 \end{bmatrix}$$

**Where:**
- $R_{3√ó3}$ = 3√ó3 rotation matrix
- $\mathbf{t}_{3√ó1}$ = 3√ó1 translation vector
- $\mathbf{0}_{1√ó3}$ = [0 0 0] zero vector
- Last element = 1 (homogeneous coordinate)

**Physical Meaning:** 4√ó4 matrices unify rotation and translation into single mathematical operation for 3D spatial transformations.
</Card>

### Composite 3D Transformations for Robotics

<BionicText method="advanced" intensity="medium" class="highlight">
Real robot control requires precise composition of multiple rotations and translations in 3D space. Understanding the systematic rules for matrix multiplication order is essential for accurate end-effector positioning and complex trajectory programming.
</BionicText>

<Card title="üîß 3D Transformation Composition Rules" icon="document">
**Matrix multiplication is non-commutative - order matters!**

**For robot positioning with multiple transformations:**

1. **Initial state:** Fixed and mobile frames are coincident ‚Üí **Identity matrix**
2. **Fixed frame operations:** Rotate/translate about fixed axes (X,Y,Z) ‚Üí **Pre-multiply** current matrix
3. **Mobile frame operations:** Rotate/translate about mobile axes (A,B,C) ‚Üí **Post-multiply** current matrix

**General composition:** **$H = H_n ¬∑ H_{n-1} ¬∑ ... ¬∑ H_2 ¬∑ H_1$**

Where transformations are applied in sequence: H_1 first, H_n last.
</Card>

<Tabs>
  <TabItem label="Basic 3D Examples">

    <details>
    <summary>**Example 1: Simple 3D rotation and translation sequence**</summary>

    <Steps>

    1. **Problem:** 40¬∞ rotation about X-axis, then 7 units translation along mobile B-axis

       **Setup:** **H = H(x,40¬∞) ¬∑ I ¬∑ H(B,7)**

    2. **Matrix composition:**

       $$
       \begin{aligned}
       H &= \begin{bmatrix}
       1 & 0 & 0 & 0 \\
       0 & \cos(40¬∞) & -\sin(40¬∞) & 0 \\
       0 & \sin(40¬∞) & \cos(40¬∞) & 0 \\
       0 & 0 & 0 & 1
       \end{bmatrix} \cdot \begin{bmatrix}
       1 & 0 & 0 & 0 \\
       0 & 1 & 0 & 7 \\
       0 & 0 & 1 & 0 \\
       0 & 0 & 0 & 1
       \end{bmatrix}
       \end{aligned}
       $$

    3. **Final result:**

       $$
       H = \begin{bmatrix}
       1 & 0 & 0 & 0 \\
       0 & 0.7660 & -0.6428 & 5.3620 \\
       0 & 0.6428 & 0.7660 & 4.4996 \\
       0 & 0 & 0 & 1
       \end{bmatrix}
       $$

    </Steps>

    </details>

  </TabItem>
  <TabItem label="Complex Sequences">

    <details>
    <summary>**Example 2: Multi-step 3D transformation sequence**</summary>

    <Steps>

    1. **Problem:** Complex robotic motion sequence
       - 50¬∞ rotation about X-axis
       - 4 units translation along X-axis
       - -6 units translation along C-axis
       - 25¬∞ rotation about B-axis

    2. **Matrix sequence:** **H = H(x,4) ¬∑ H(x,50¬∞) ¬∑ I ¬∑ H(c,-6) ¬∑ H(b,25¬∞)**

    3. **Step-by-step computation:**

       $$
       \begin{aligned}
       H &= \begin{bmatrix}1 & 0 & 0 & 4 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1\end{bmatrix} \cdot
       \begin{bmatrix}1 & 0 & 0 & 0 \\ 0 & 0.6428 & -0.7660 & 0 \\ 0 & 0.7660 & 0.6428 & 0 \\ 0 & 0 & 0 & 1\end{bmatrix} \\
       &\times \begin{bmatrix}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & -6 \\ 0 & 0 & 0 & 1\end{bmatrix} \cdot
       \begin{bmatrix}0.9063 & 0 & 0.4226 & 0 \\ 0 & 1 & 0 & 0 \\ -0.4226 & 0 & 0.9063 & 0 \\ 0 & 0 & 0 & 1\end{bmatrix}
       \end{aligned}
       $$

    4. **Final transformation matrix:**

       $$
       H = \begin{bmatrix}
       0.9063 & 0 & 0.4226 & 4.0 \\
       0.3237 & 0.6428 & -0.6943 & 4.596 \\
       -0.2717 & 0.766 & 0.5826 & -3.857 \\
       0 & 0 & 0 & 1.0
       \end{bmatrix}
       $$

    </Steps>

    </details>

  </TabItem>
  <TabItem label="Vision System Applications">

    <details>
    <summary>**Example 3: Robot vision system coordinate transformations**</summary>

    <Steps>

    1. **System setup:** Robotic work cell with camera and 6-joint robot
       - **H‚ÇÅ**: Camera to object transformation
       - **H‚ÇÇ**: Camera to robot base transformation
       - **H‚ÇÉ**: Base to gripper transformation

    2. **Given transformation matrices:**

       $$
       \begin{aligned}
       H_1 &= \begin{bmatrix}0 & 1 & 0 & 4 \\ 1 & 0 & 0 & 3 \\ 0 & 0 & -1 & 7 \\ 0 & 0 & 0 & 1\end{bmatrix} \\
       H_2 &= \begin{bmatrix}1 & 0 & 0 & -15 \\ 0 & -1 & 0 & 5 \\ 0 & 0 & -1 & 6 \\ 0 & 0 & 0 & 1\end{bmatrix} \\
       H_3 &= \begin{bmatrix}1 & 0 & 0 & 7 \\ 0 & 1 & 0 & 2 \\ 0 & 0 & 1 & 3 \\ 0 & 0 & 0 & 1\end{bmatrix}
       \end{aligned}
       $$

    3. **Object position relative to robot base:**

       $$
       \begin{aligned}
       {}^{base}T_{object} &= {}^{base}T_{camera} \cdot {}^{camera}T_{object} \\
       &= [H_2]^{-1} \cdot [H_1] \\
       &= \begin{bmatrix}0 & 1 & 0 & 19 \\ -1 & 0 & 0 & 2 \\ 0 & 0 & 1 & -1 \\ 0 & 0 & 0 & 1\end{bmatrix}
       \end{aligned}
       $$

    4. **Object position relative to gripper:**

       $$
       \begin{aligned}
       {}^{gripper}T_{object} &= {}^{gripper}T_{base} \cdot {}^{base}T_{object} \\
       &= [H_3]^{-1} \cdot [H_2]^{-1} \cdot [H_1] \\
       &= \begin{bmatrix}0 & 1 & 0 & 12 \\ -1 & 0 & 0 & 0 \\ 0 & 0 & 1 & -4 \\ 0 & 0 & 0 & 1\end{bmatrix}
       \end{aligned}
       $$

    </Steps>

    </details>

  </TabItem>
</Tabs>

### Euler Angle Representations

<BionicText method="advanced" intensity="medium" class="highlight">
Euler angles provide an intuitive way to describe 3D orientations using three sequential rotations about coordinate axes. However, different sequences exist and singularities must be carefully managed. Additionally, the terminology (roll, pitch, yaw) depends heavily on which coordinate system convention is being used.
</BionicText>

:::note[Important: Coordinate System Conventions Matter!]
<div style={{ display: 'flex', justifyContent: 'center', width: '100%' }}>
  <TailwindWrapper>
    <img src="https://pub-b1eb899abc464b5baf5b9521d163efd9.r2.dev/spatial-mechanics/roll-pitch-yaw.gif" alt="Roll, Pitch, and Yaw rotations visualization" style={{ maxWidth: '100%', height: 'auto' }} />
  </TailwindWrapper>
</div>

The physical meanings of **roll**, **pitch**, and **yaw** don't change, but **which mathematical axis (X, Y, Z) corresponds to which rotation depends entirely on your coordinate system**. Always verify which coordinate system convention is being used when working with Euler angles! Different fields use different conventions:

**Aerospace/Aviation Convention:**
<div style={{ display: 'flex', justifyContent: 'center', width: '100%' }}>
  <TailwindWrapper>
    <img src="https://pub-b1eb899abc464b5baf5b9521d163efd9.r2.dev/spatial-mechanics/aerospace-aviation-xyz-convention.svg" alt="Roll, Pitch, and Yaw Aerospace Aviation Convention" style={{ maxWidth: '100%', height: 'auto' }} />
  </TailwindWrapper>
</div>
- **Axes:** X = forward (nose), Y = right (wing), Z = down (belly)
- **Rotations:** Roll = rotation about X (longitudinal), Pitch = rotation about Y (lateral/horizontal), Yaw = rotation about Z (vertical)

**Mathematics/Robotics Convention *(used in this course)*:**
<div style={{ display: 'flex', justifyContent: 'center', width: '100%' }}>
  <TailwindWrapper>
    <img src="https://pub-b1eb899abc464b5baf5b9521d163efd9.r2.dev/spatial-mechanics/math-robotics-xyz-convention.svg" alt="Roll, Pitch, and Yaw Mathematics Robotics Convention" style={{ maxWidth: '100%', height: 'auto' }} />
  </TailwindWrapper>
</div>
- **Axes:** X = right, Y = up, Z = forward
- **Rotations:** Roll = rotation about Z (longitudinal), Pitch = rotation about X (lateral/horizontal), Yaw = rotation about Y (vertical)

**Key Point:** Roll always means "banking" (rotating around the forward-pointing axis), Pitch means "nodding" (tilting up/down), and Yaw means "turning" (spinning left/right). But which axis is X, Y, or Z depends on your coordinate system!

:::

<Tabs>
  <TabItem label="ZYX Convention">

    <Card title="üéØ ZYX Euler Angles" icon="document">
    **Sequential rotations:**
    1. Rotate Œ≥ about Z-axis (Roll in Math/Robotics convention)
    2. Rotate Œ≤ about new Y-axis (Yaw in Math/Robotics convention)
    3. Rotate Œ± about final X-axis (Pitch in Math/Robotics convention)

    **Combined rotation matrix:**
    $$R_{ZYX}(\gamma, \beta, \alpha) = R_x(\alpha) R_y(\beta) R_z(\gamma)$$

    **Physical Meaning:** Commonly used in robotics and computer graphics. The sequence applies Z rotation first, then Y rotation, then X rotation.

    **Note:** Matrix multiplication order is right-to-left, so $R_z(\gamma)$ is applied first to the vector, then $R_y(\beta)$, then $R_x(\alpha)$.
    </Card>

  </TabItem>
  <TabItem label="ZYZ Convention">

    <Card title="üéØ ZYZ Euler Angles (Classical)" icon="document">
    **Sequential rotations:**
    1. Rotate Œ≥ about Z-axis (first Z rotation)
    2. Rotate Œ≤ about new Y-axis (nutation angle)
    3. Rotate Œ± about final Z-axis (second Z rotation)

    **Combined rotation matrix:**
    $$R_{ZYZ}(\gamma, \beta, \alpha) = R_z(\alpha) R_y(\beta) R_z(\gamma)$$

    **Physical Meaning:** Classical mechanics convention, particularly useful for:
    - Gyroscope orientation analysis
    - Spacecraft attitude control
    - Systems with natural symmetry about one axis

    **Advantage:** Often more natural for systems with cylindrical or axial symmetry.
    </Card>

  </TabItem>
  <TabItem label="Singularity Issues">

    **Gimbal Lock phenomenon:**
    - Occurs when middle rotation angle reaches critical values
    - Results in loss of one degree of freedom
    - Two rotation axes become parallel (aligned)
    - Mathematical: Jacobian matrix becomes singular

    **ZYX singularity:** Œ≤ = ¬±90¬∞ (pitch vertical - looking straight up or down)
    **ZYZ singularity:** Œ≤ = 0¬∞ or 180¬∞ (middle Y-rotation collapses)

    **At singularity:**
    - Cannot uniquely determine all three angles
    - Small changes in orientation cause large angle changes
    - Numerical instability in conversions

    **Avoidance strategies:**
    - Use alternative Euler angle sequences near singularities
    - Switch between different conventions dynamically
    - Employ quaternion representations (no singularities)
    - Plan trajectories to avoid singular configurations

  </TabItem>
</Tabs>

### Rotation About an Arbitrary Axis Through the Origin

<div style={{ display: 'flex', justifyContent: 'center', width: '100%' }}>
  <TailwindWrapper>
	![Rotation about an Arbitrary Axes](https://pub-b1eb899abc464b5baf5b9521d163efd9.r2.dev/spatial-mechanics/arbitrary-axes.svg)
  </TailwindWrapper>
</div>

<BionicText method="advanced" intensity="medium" class="highlight">
Rotation about an arbitrary axis is essential when the rotation cannot be decomposed into simple X, Y, Z rotations. Two primary methods exist: the decomposition approach and Rodrigues' formula. Each has specific advantages depending on the application context.
</BionicText>

**Problem Setup:** Given a fixed frame OXYZ and an arbitrary rotation axis **V = (x,y,z)** with components **V_x, V_y, V_z**, we need to construct the rotation matrix **R(V,Œ∏)** for rotation angle **Œ∏**.

## Method 1: Decomposition Approach (General Arbitrary Axis Formula)

<Card title="üîÑ Arbitrary Axis Rotation Strategy" icon="document">
**Five-step decomposition process:**

1. Rotation by angle **Œ±** about X-axis
2. Rotation by angle **-Œ≤** about Y-axis
3. Rotation by angle **Œ∏** about Z-axis
4. Rotation by angle **Œ≤** about Y-axis
5. Rotation by angle **-Œ±** about X-axis

**Matrix composition:** **R(V,Œ∏) = R(x,-Œ±) R(y,Œ≤) R(z,Œ∏) R(y,-Œ≤) R(x,Œ±)**
</Card>

**The complete rotation matrix:**

$$
R(V,Œ∏) = \begin{bmatrix}
1 & 0 & 0 \\
0 & \cos\alpha & \sin\alpha \\
0 & -\sin\alpha & \cos\alpha
\end{bmatrix}\begin{bmatrix}
\cos\beta & 0 & \sin\beta \\
0 & 1 & 0 \\
-\sin\beta & 0 & \cos\beta
\end{bmatrix}\begin{bmatrix}
\cos\theta & -\sin\theta & 0 \\
\sin\theta & \cos\theta & 0 \\
0 & 0 & 1
\end{bmatrix}\begin{bmatrix}
\cos\beta & 0 & -\sin\beta \\
0 & 1 & 0 \\
\sin\beta & 0 & \cos\beta
\end{bmatrix}\begin{bmatrix}
1 & 0 & 0 \\
0 & \cos\alpha & -\sin\alpha \\
0 & \sin\alpha & \cos\alpha
\end{bmatrix}
$$

**Geometric relationships:** For unit vector **|V| = 1**:

$$
\begin{aligned}
\sin\alpha &= \frac{V_y}{\sqrt{V_y^2+V_z^2}}, \quad \cos\alpha = \frac{V_z}{\sqrt{V_y^2+V_z^2}} \\
\sin\beta &= V_x, \quad \cos\beta = \sqrt{V_y^2+V_z^2}
\end{aligned}
$$

<Card title="‚ö° Simplified Arbitrary Axis Formula" icon="star">
**Final rotation matrix in compact form:**

$$
R(V,Œ∏) = \begin{bmatrix}
V_x^2 T + C & V_x V_y T - V_z S & V_x V_z T + V_y S \\
V_x V_y T + V_z S & V_y^2 T + C & V_y V_z T - V_x S \\
V_x V_z T - V_y S & V_y V_z T + V_x S & V_z^2 T + C
\end{bmatrix}
$$

**Where:** **C = cos Œ∏**, **S = sin Œ∏**, **T = (1 - cos Œ∏)**

**Unit vector components:**
$$V_x = \frac{x}{\sqrt{x^2+y^2+z^2}}, \quad V_y = \frac{y}{\sqrt{x^2+y^2+z^2}}, \quad V_z = \frac{z}{\sqrt{x^2+y^2+z^2}}$$
</Card>

**Example:** 90¬∞ rotation about V = (2, 2, 2)

<details>
<summary>**Click to reveal decomposition method calculations**</summary>

<Steps>

1. **Calculate unit vector components:**

   $$V_x = V_y = V_z = \frac{2}{2\sqrt{3}} = \frac{1}{\sqrt{3}} = 0.5774$$

2. **Calculate trigonometric values:**

   $$C = \cos(90¬∞) = 0, \quad S = \sin(90¬∞) = 1, \quad T = 1 - 0 = 1$$

3. **Compute matrix elements using compact formula:**

   $$
   \begin{aligned}
   r_{11} &= V_x^2 T + C = (0.5774)^2(1) + 0 = 0.3333 = \frac{1}{3} \\
   r_{12} &= V_x V_y T - V_z S = (0.5774)(0.5774)(1) - (0.5774)(1) = -0.2440 \\
   r_{13} &= V_x V_z T + V_y S = (0.5774)(0.5774)(1) + (0.5774)(1) = 0.9107
   \end{aligned}
   $$

4. **Final rotation matrix:**

   $$
   R(V,90¬∞) = \begin{bmatrix}
   0.333 & -0.244 & 0.911 \\
   0.911 & 0.333 & -0.244 \\
   -0.244 & 0.911 & 0.333
   \end{bmatrix}
   $$

</Steps>

</details>

:::tip[When to Use Decomposition Approach]
**Best for:**
- Hand calculations and analytical derivations
- Understanding the geometric decomposition
- Teaching and learning rotation concepts
- When rotation axis alignment with coordinate axes is important

**Advantages:**
- Intuitive geometric interpretation
- Systematic step-by-step process
- Direct connection to Euler angle concepts

**Disadvantages:**
- More computationally expensive (multiple matrix multiplications)
- More complex to implement in code
:::

## Method 2: Rodrigues' Rotation Formula

<BionicText method="advanced" intensity="medium" class="highlight">
Rodrigues' formula provides a compact, elegant expression for arbitrary axis rotations using matrix exponentials and the skew-symmetric matrix form. This is the preferred method for computational implementations.
</BionicText>

<Card title="‚ö° Rodrigues' Rotation Formula" icon="star">
**Matrix exponential form:**

$$R(V,Œ∏) = e^{WŒ∏} = I + \sin(Œ∏) W + (1-\cos(Œ∏)) W^2$$

**Where:**
- **I** = 3√ó3 identity matrix
- **W** = skew-symmetric matrix of unit vector $\hat{V}$
- **Œ∏** = rotation angle

**Skew-symmetric matrix construction:**
$$
W = \begin{bmatrix}
0 & -V_z & V_y \\
V_z & 0 & -V_x \\
-V_y & V_x & 0
\end{bmatrix}
$$

**Key property:** $W^2 = \hat{V}\hat{V}^T - I$ (outer product minus identity)

**Note:** Rodrigues formula only works for rotations about axes passing through the origin.
</Card>

**Example:** Same 90¬∞ rotation about V = (2, 2, 2) using Rodrigues

<details>
<summary>**Click to reveal Rodrigues method calculations**</summary>

<Steps>

1. **Unit vector:** $\hat{V} = [0.5774, 0.5774, 0.5774]^T$

2. **Skew-symmetric matrix W:**

   $$
   W = \begin{bmatrix}
   0 & -0.5774 & 0.5774 \\
   0.5774 & 0 & -0.5774 \\
   -0.5774 & 0.5774 & 0
   \end{bmatrix}
   $$

3. **Compute W¬≤:**

   $$
   W^2 = W \cdot W = \begin{bmatrix}
   -0.667 & 0.333 & 0.333 \\
   0.333 & -0.667 & 0.333 \\
   0.333 & 0.333 & -0.667
   \end{bmatrix}
   $$

4. **Apply Rodrigues formula:**

   $$R = I + \sin(90¬∞) W + (1-\cos(90¬∞)) W^2$$

   $$R = I + 1 \cdot W + 1 \cdot W^2$$

   $$
   R = \begin{bmatrix}1&0&0\\0&1&0\\0&0&1\end{bmatrix} + \begin{bmatrix}0&-0.577&0.577\\0.577&0&-0.577\\-0.577&0.577&0\end{bmatrix} + \begin{bmatrix}-0.667&0.333&0.333\\0.333&-0.667&0.333\\0.333&0.333&-0.667\end{bmatrix}
   $$

   $$
   R = \begin{bmatrix}
   0.333 & -0.244 & 0.911 \\
   0.911 & 0.333 & -0.244 \\
   -0.244 & 0.911 & 0.333
   \end{bmatrix}
   $$  
   ‚úÖ (same result!)

</Steps>

</details>

:::tip[When to Use Rodrigues Formula]
**Best for:**
- Computational implementations (robotics, graphics, simulation)
- Quaternion-to-matrix conversions
- Real-time applications requiring efficiency
- Interpolation between orientations (SLERP)

**Advantages:**
- Computationally efficient (requires only 2 matrix operations)
- Elegant mathematical formulation
- Direct connection to Lie algebra/exponential map theory
- Easy to implement in code (fewer operations)

**Disadvantages:**
- Less intuitive geometric interpretation
- Requires understanding of skew-symmetric matrices
:::

### Comparison and Method Selection

| Criterion | Decomposition | Rodrigues |
|-----------|---------------|-----------|
| **Computational cost** | High (5 matrix mults) | Low (2 matrix ops) |
| **Code complexity** | Medium | Low |
| **Geometric intuition** | Excellent | Poor |
| **Numerical stability** | Good | Excellent |
| **Best use case** | Education, analysis | Implementation |
| **Connection to** | Euler angles | Quaternions |

**General recommendation:** Use Rodrigues' formula for all computational work (robot control, graphics engines, simulation). Use decomposition approach for teaching, learning, and analytical derivations.

## üè≠ Application 1: Robotic Welding of Pipe Joints (Manufacturing)

A 3-axis welding robot must perform orbital welding around a horizontal pipe with the torch perpendicular to the pipe surface at key positions around the weld.

:::note[System Problem Statement]
- **Configuration:** 3-axis welding robot with welding torch
- **Workpiece:** 200mm diameter horizontal steel pipe (aligned with X-axis)
- **Task:** Calculate torch orientation at 4 key waypoints (top, side, bottom, side) around pipe circumference
<div style={{ display: 'flex', justifyContent: 'center', width: '100%' }}>
  <TailwindWrapper>
	![Robotic Pipe Welding Setup](https://pub-b1eb899abc464b5baf5b9521d163efd9.r2.dev/spatial-mechanics/robotic-pipe-welding.jpg)
  </TailwindWrapper>
</div>
**What we need to calculate:**
1. **Surface normal vectors** at 4 waypoints around pipe circumference (0¬∞, 90¬∞, 180¬∞, 270¬∞)
2. **Tool orientation matrices** ensuring torch perpendicularity to surface
3. **Euler angle sequences** (ZYX convention) for robot controller
4. **Verification** that torch remains perpendicular to pipe surface

**Key Question:** How do we systematically calculate 3D rotation matrices to maintain torch perpendicularity at different positions around a cylindrical surface?
:::

<Card title="üîß Equivalent System Model" icon="document">
<div style={{ display: 'flex', justifyContent: 'center', width: '100%' }}>
  <TailwindWrapper>
	![Pipe Welding Geometry](https://pub-b1eb899abc464b5baf5b9521d163efd9.r2.dev/spatial-mechanics/pipe-welding-geometry.png)
  </TailwindWrapper>
</div>
**Given:**
- **Pipe parameters:** Radius R = 100 mm, horizontal pipe aligned with X-axis
- **Pipe centerline direction:** $\hat{p} = (1, 0, 0)$ (along X-axis)
- **Starting point:** Œ∏ = 0¬∞ at top of pipe (pointing in +Z direction)
- **Torch requirements:** Torch Z-axis must align with surface normal (pointing radially outward from pipe)
- **Waypoints:** 4 cardinal points (Œ∏ = 0¬∞, 90¬∞, 180¬∞, 270¬∞)
- **Coordinate system:** YZ-plane is perpendicular to pipe axis
</Card>

### Step 1: Surface Normal Calculation at Waypoints

<details>
<summary>**Click to reveal surface normal calculations**</summary>

<Steps>

1. **Understanding the coordinate system and notation:**

   **Coordinate system setup (RIGHT-HANDED):**
   - The **X-axis** runs horizontally left-to-right (pipe direction)
   - The **Y-axis** points upward vertically (toward the ceiling)
   - The **Z-axis** points to the side (imagine lying along X-axis: legs at left, head at right, Z points to your left side)
   - Alternative Z-axis description: when viewing the XY plane on paper, Z comes **out of the paper** toward you
   - We look at the pipe's circular cross-section in the **YZ-plane** 

   **Vector notation explained:**
   - $\hat{x}$, $\hat{y}$, $\hat{z}$ are **unit vectors** (length = 1) pointing along each axis
   - $\hat{x} = (1, 0, 0)$ means "1 unit in X-direction, 0 in Y, 0 in Z"
   - $\hat{y} = (0, 1, 0)$ means "0 in X, 1 unit in Y-direction (upward), 0 in Z"
   - $\hat{z} = (0, 0, 1)$ means "0 in X, 0 in Y, 1 unit in Z-direction (out toward you)"
   - $\hat{n}$ means "unit normal vector" (perpendicular to the pipe surface, pointing radially outward)

   **Angular position Œ∏ convention:**
   - We define **Œ∏ = 0¬∞ at the TOP of the pipe** (highest point, where normal points straight up in +Y direction)
   - Œ∏ increases as we rotate **clockwise** when viewing from the left (looking down the pipe in +X direction)
   - This is a **choice of convention** - we could pick any starting point, but starting at the top is intuitive

2. **Geometric reasoning - where does the normal point?**

   Imagine standing at the left end of the pipe, looking at the circular cross-section in the YZ-plane:

   - **At Œ∏ = 0¬∞ (top):** Normal points **straight up** ‚Üí +Y-direction ‚Üí $\hat{n} = \hat{y} = (0, 1, 0)$
   - **At Œ∏ = 90¬∞ (toward you):** Normal points **out of paper** ‚Üí +Z-direction ‚Üí $\hat{n} = \hat{z} = (0, 0, 1)$
   - **At Œ∏ = 180¬∞ (bottom):** Normal points **straight down** ‚Üí -Y-direction ‚Üí $\hat{n} = -\hat{y} = (0, -1, 0)$
   - **At Œ∏ = 270¬∞ (away from you):** Normal points **into paper** ‚Üí -Z-direction ‚Üí $\hat{n} = -\hat{z} = (0, 0, -1)$

3. **Deriving the formula for surface normal:**

   Looking at the circular cross-section in the YZ-plane, the normal vector rotates around the circle.

   **At angle Œ∏ measured clockwise from the top:**
   - The **vertical component** (Y) starts at 1, decreases: this follows **cosine**
   - The **Z component** (out of paper) starts at 0, increases: this follows **sine**

   **General formula:**
   $$\hat{n}(\theta) = \cos\theta \cdot \hat{y} + \sin\theta \cdot \hat{z}$$

   This means: "Mix the up-direction ($\hat{y}$) and out-of-paper direction ($\hat{z}$) using cosine and sine to get the correct angle."

4. **Calculating surface normal at Œ∏ = 0¬∞ (top of pipe):**

   $$\hat{n}(0¬∞) = \cos(0¬∞) \cdot \hat{y} + \sin(0¬∞) \cdot \hat{z}$$

   **Substitute values:** $\cos(0¬∞) = 1$ and $\sin(0¬∞) = 0$

   $$\hat{n}(0¬∞) = 1 \cdot \hat{y} + 0 \cdot \hat{z} = \hat{y}$$

   **Convert to coordinates:** $\hat{y} = (0, 1, 0)$

   $$\hat{n}(0¬∞) = (0, 1, 0)$$ ‚úÖ

   **Interpretation:**
   - X-component = 0 (doesn't point along pipe)
   - Y-component = 1 (points straight up!)
   - Z-component = 0 (no out-of-paper component)

5. **Calculating surface normal at Œ∏ = 90¬∞ (side toward you):**

   $$\hat{n}(90¬∞) = \cos(90¬∞) \cdot \hat{y} + \sin(90¬∞) \cdot \hat{z}$$

   **Substitute values:** $\cos(90¬∞) = 0$ and $\sin(90¬∞) = 1$

   $$\hat{n}(90¬∞) = 0 \cdot \hat{y} + 1 \cdot \hat{z} = \hat{z}$$

   **Convert to coordinates:** $\hat{z} = (0, 0, 1)$

   $$\hat{n}(90¬∞) = (0, 0, 1)$$ ‚úÖ

   **Interpretation:**
   - X-component = 0 (doesn't point along pipe)
   - Y-component = 0 (no vertical component)
   - Z-component = 1 (points out of paper toward you!)

6. **General formula in coordinate form:**

   $$\hat{n}(\theta) = \cos\theta \cdot (0,1,0) + \sin\theta \cdot (0,0,1) = (0, \cos\theta, \sin\theta)$$

   Written as a column vector:
   $$\hat{n}(\theta) = \begin{bmatrix} 0 \\ \cos\theta \\ \sin\theta \end{bmatrix}$$ ‚úÖ

7. **All 4 waypoint normal vectors:**

   | Point | Œ∏ (¬∞) | Calculation | n_x | n_y | n_z | Physical Direction | \|n\| |
   |-------|-------|-------------|---------|---------|---------|-------------------|-------|
   | 0 | 0 | (0, cos 0¬∞, sin 0¬∞) | 0 | 1 | 0 | Top (+Y) | 1.000 ‚úÖ |
   | 1 | 90 | (0, cos 90¬∞, sin 90¬∞) | 0 | 0 | 1 | Side (+Z, toward you) | 1.000 ‚úÖ |
   | 2 | 180 | (0, cos 180¬∞, sin 180¬∞) | 0 | -1 | 0 | Bottom (-Y) | 1.000 ‚úÖ |
   | 3 | 270 | (0, cos 270¬∞, sin 270¬∞) | 0 | 0 | -1 | Side (-Z, away) | 1.000 ‚úÖ |

</Steps>

</details>

### Step 2: Tool Orientation Matrix Construction

<details>
<summary>**Click to reveal orientation matrix calculations**</summary>

<Steps>

1. **What is a "tool frame" and why do we need it?**

   **The welding torch has its own coordinate system** attached to it:
   - The torch must point perpendicular to the pipe surface (to make a good weld)
   - We need to describe which way the torch is pointing in 3D space
   - We do this by defining three perpendicular axes attached to the torch

   **Tool frame axis definitions:**
   - **Z-axis (torch tip direction):** Points where the torch is aimed - must align with surface normal $\hat{n}(\theta)$ to be perpendicular to pipe
   - **X-axis (torch advance direction):** Points along the welding direction - we choose this to be along the pipe axis = $(1, 0, 0)$
   - **Y-axis (torch side direction):** Points to the side of the torch - calculated automatically to complete a right-handed coordinate system

   **Why these choices?**
   - Z-axis MUST be perpendicular to the pipe (required for welding)
   - X-axis along the pipe makes sense because the torch moves along the pipe
   - Y-axis is whatever's left to make the three axes perpendicular to each other

2. **Tool orientation at Œ∏ = 0¬∞ (top of pipe):**

   **What we know:**
   - At the top, the surface normal points straight up: $\hat{n}(0¬∞) = (0, 1, 0)$
   - This means the torch must point upward too

   **Building the tool frame step-by-step:**

   **Step 2a: Z-axis (where torch points):**
   - Torch must be perpendicular to pipe surface
   - At top of pipe, this means pointing upward (in +Y direction): $\mathbf{z}_{tool} = (0, 1, 0)$ ‚úÖ

   **Step 2b: X-axis (welding direction):**
   - We choose this to be along the pipe: $\mathbf{x}_{tool} = (1, 0, 0)$ ‚úÖ

   **Step 2c: Y-axis (complete the frame):**
   - Must be perpendicular to both X and Z axes
   - We use the **cross product**: $\mathbf{y}_{tool} = \mathbf{z}_{tool} \times \mathbf{x}_{tool}$

   **Cross product calculation:**
   $$\mathbf{y}_{tool} = (0, 1, 0) \times (1, 0, 0)$$

   Using cross product formula: $(a_1, a_2, a_3) \times (b_1, b_2, b_3) = (a_2 b_3 - a_3 b_2, a_3 b_1 - a_1 b_3, a_1 b_2 - a_2 b_1)$

   $$= (1 \cdot 0 - 0 \cdot 0, 0 \cdot 1 - 0 \cdot 0, 0 \cdot 0 - 1 \cdot 1) = (0, 0, -1)$$ ‚úÖ

   **Step 2d: Build the rotation matrix:**
   - A rotation matrix has the tool frame axes as its **columns**
   - Format: $R = [\mathbf{x}_{tool} | \mathbf{y}_{tool} | \mathbf{z}_{tool}]$ (three column vectors side-by-side)

   $$
   R_{tool}(0¬∞) = \begin{bmatrix}
   \text{x-axis} & \text{y-axis} & \text{z-axis} \\
   1 & 0 & 0 \\
   0 & 0 & 1 \\
   0 & -1 & 0
   \end{bmatrix}
   $$ 

   **Physical meaning:** At the top of the pipe, the torch points upward (+Y), moves along the pipe (+X), with Y-axis pointing away from you (-Z). ‚úÖ

3. **Tool orientation at Œ∏ = 90¬∞ (side toward you):**

   **What we know:**
   - At the side, the surface normal points out toward you: $\hat{n}(90¬∞) = (0, 0, 1)$
   - This means the torch must point toward you

   **Building the tool frame:**

   **Step 3a: Z-axis (where torch points):**
   - Must point toward you (in +Z direction): $\mathbf{z}_{tool} = (0, 0, 1)$ ‚úÖ

   **Step 3b: X-axis (welding direction):**
   - Still along the pipe: $\mathbf{x}_{tool} = (1, 0, 0)$ ‚úÖ

   **Step 3c: Y-axis (cross product):**
   $$\mathbf{y}_{tool} = \mathbf{z}_{tool} \times \mathbf{x}_{tool} = (0, 0, 1) \times (1, 0, 0)$$
   $$= (0 \cdot 0 - 1 \cdot 0, 1 \cdot 1 - 0 \cdot 0, 0 \cdot 0 - 0 \cdot 1) = (0, 1, 0)$$ ‚úÖ

   **Step 3d: Build the rotation matrix:**
   $$
   R_{tool}(90¬∞) = \begin{bmatrix}
   1 & 0 & 0 \\
   0 & 1 & 0 \\
   0 & 0 & 1
   \end{bmatrix} = I
   $$ 

   **Physical meaning:** At Œ∏ = 90¬∞, the tool frame aligns with the world frame! The torch points toward you (+Z), moves along pipe (+X), with Y-axis pointing up (+Y). ‚úÖ

4. **Complete the other waypoints (Œ∏ = 180¬∞ and 270¬∞):**

   Following the same process for the bottom and other side:

   **At Œ∏ = 180¬∞ (bottom):**
   - Surface normal: $\hat{n}(180¬∞) = (0, -1, 0)$ (points down)
   - Z-axis: $(0, -1, 0)$, X-axis: $(1, 0, 0)$
   - Y-axis: $(0, -1, 0) \times (1, 0, 0) = (0, 0, 1)$

   **Rotation matrix:**
   $$R_{tool}(180¬∞) = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 0 & -1 \\ 0 & 1 & 0 \end{bmatrix}$$

   **At Œ∏ = 270¬∞ (away from you):**
   - Surface normal: $\hat{n}(270¬∞) = (0, 0, -1)$ (points away)
   - Z-axis: $(0, 0, -1)$, X-axis: $(1, 0, 0)$
   - Y-axis: $(0, 0, -1) \times (1, 0, 0) = (0, -1, 0)$

   **Rotation matrix:**
   $$R_{tool}(270¬∞) = \begin{bmatrix} 1 & 0 & 0 \\ 0 & -1 & 0 \\ 0 & 0 & -1 \end{bmatrix}$$

5. **Summary table of all 4 waypoints:**

   | Œ∏ (¬∞) | Position | Torch Points | X-axis | Y-axis | Z-axis | R_tool (3√ó3 matrix) |
   |-------|----------|--------------|--------|--------|--------|---------------------|
   | 0 | Top | Up (+Y) | (1,0,0) | (0,0,-1) | (0,1,0) | $\begin{bmatrix} 1 & 0 & 0 \\ 0 & 0 & 1 \\ 0 & -1 & 0 \end{bmatrix}$ |
   | 90 | Side | Toward you (+Z) | (1,0,0) | (0,1,0) | (0,0,1) | $\begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}$ |
   | 180 | Bottom | Down (-Y) | (1,0,0) | (0,0,1) | (0,-1,0) | $\begin{bmatrix} 1 & 0 & 0 \\ 0 & 0 & -1 \\ 0 & 1 & 0 \end{bmatrix}$ |
   | 270 | Side | Away (-Z) | (1,0,0) | (0,-1,0) | (0,0,-1) | $\begin{bmatrix} 1 & 0 & 0 \\ 0 & -1 & 0 \\ 0 & 0 & -1 \end{bmatrix}$ |

6. **Important pattern to recognize:**

   **Look at the first column** of all the matrices - it's always $(1, 0, 0)$!
   - This is the X-axis, which always points along the pipe
   - This column never changes because the torch always moves along the pipe axis

   **The key insight:**
   - All these matrices represent **pure rotations about the X-axis** (the pipe)
   - Œ∏ = 0¬∞: Rotation by some angle about X-axis
   - Œ∏ = 90¬∞: Identity (world frame aligned)
   - Œ∏ = 180¬∞: Another rotation about X-axis
   - Œ∏ = 270¬∞: Another rotation about X-axis

   **Physical interpretation:**
   - Imagine holding the pipe with your right hand, thumb pointing along +X
   - As you rotate around the pipe clockwise (when viewing from left), the torch rotates with you
   - The torch always stays perpendicular to the pipe surface
   - You're just doing a simple roll motion about the pipe axis!

</Steps>

</details>

### Step 3: Euler Angle Extraction (ZYX Convention)

<details>
<summary>**Click to reveal Euler angle extraction**</summary>

<Steps>

1. **What are Euler angles and why do we need them?**

   **The problem:**
   - We have rotation matrices that describe the torch orientation
   - But robot controllers don't understand matrices directly
   - They need **three simple rotation angles**: roll, pitch, and yaw

   **What are Euler angles?**
   - **Roll (Œ±):** Rotation about X-axis (like a plane banking left/right)
   - **Pitch (Œ≤):** Rotation about Y-axis (like a plane nose up/down)
   - **Yaw (Œ≥):** Rotation about Z-axis (like a plane turning left/right)

   **ZYX convention** means: apply rotations in order Z, then Y, then X (but we extract them in reverse!)

2. **The extraction formulas (you don't need to memorize these!):**

   Given rotation matrix $R = \begin{bmatrix} r_{11} & r_{12} & r_{13} \\ r_{21} & r_{22} & r_{23} \\ r_{31} & r_{32} & r_{33} \end{bmatrix}$:

   These formulas extract the angles by looking at specific matrix elements:
   - **Pitch (Œ≤):** $\beta = \arcsin(-r_{31})$ (looks at position row 3, column 1)
   - **Roll (Œ±):** $\alpha = \arctan2(r_{32}, r_{33})$ (looks at positions row 3, columns 2 & 3)
   - **Yaw (Œ≥):** $\gamma = \arctan2(r_{21}, r_{11})$ (looks at positions rows 2 & 1, column 1)

   **Don't worry about deriving these** - they come from the ZYX rotation sequence definition. Just know how to use them!

3. **Extracting Euler angles at Œ∏ = 0¬∞ (top of pipe):**

   **Our rotation matrix:**
   $$R_{tool}(0¬∞) = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 0 & 1 \\ 0 & -1 & 0 \end{bmatrix}$$

   **Labeling the elements:**
   $$R = \begin{bmatrix} r_{11}=1 & r_{12}=0 & r_{13}=0 \\ r_{21}=0 & r_{22}=0 & r_{23}=1 \\ r_{31}=0 & r_{32}=-1 & r_{33}=0 \end{bmatrix}$$

   **Calculating pitch:**
   $$\beta = \arcsin(-r_{31}) = \arcsin(-0) = \arcsin(0) = 0¬∞$$ ‚úÖ

   **Calculating roll:**
   $$\alpha = \arctan2(r_{32}, r_{33}) = \arctan2(-1, 0) = -90¬∞$$ ‚úÖ

   **Calculating yaw:**
   $$\gamma = \arctan2(r_{21}, r_{11}) = \arctan2(0, 1) = 0¬∞$$ ‚úÖ

   **Result:** (roll, pitch, yaw) = (-90¬∞, 0¬∞, 0¬∞)

   **Physical meaning:** A -90¬∞ roll about X-axis - torch points upward.

4. **Extracting Euler angles at Œ∏ = 90¬∞ (side toward you):**

   **Our rotation matrix:**
   $$R_{tool}(90¬∞) = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}$$

   **Labeling the elements:**
   $$R = \begin{bmatrix} r_{11}=1 & r_{12}=0 & r_{13}=0 \\ r_{21}=0 & r_{22}=1 & r_{23}=0 \\ r_{31}=0 & r_{32}=0 & r_{33}=1 \end{bmatrix}$$

   **Calculating pitch:**
   $$\beta = \arcsin(-r_{31}) = \arcsin(-0) = 0¬∞$$ ‚úÖ

   **Calculating roll:**
   $$\alpha = \arctan2(r_{32}, r_{33}) = \arctan2(0, 1) = 0¬∞$$ ‚úÖ

   **Calculating yaw:**
   $$\gamma = \arctan2(r_{21}, r_{11}) = \arctan2(0, 1) = 0¬∞$$ ‚úÖ

   **Result:** (roll, pitch, yaw) = (0¬∞, 0¬∞, 0¬∞)

   **Physical meaning:** This is the "home" position - torch points toward you at the side of the pipe.

5. **What about gimbal lock (singularities)?**

   **The danger zone:** If pitch Œ≤ = ¬±90¬∞, the formulas break down (gimbal lock!)

   **Checking for gimbal lock:**
   - Singularity happens when $|r_{31}| = 1$
   - For all our waypoints: $r_{31} = 0$
   - Therefore: $|r_{31}| = 0 < 1$ ‚úÖ (safe!)

   **Why are we safe?**
   - Our torch never pitches up or down (pitch always = 0¬∞)
   - We only roll around the pipe
   - The horizontal pipe geometry prevents gimbal lock!

6. **Summary: Euler angles for all 4 waypoints:**

   Calculating for the remaining two waypoints (Œ∏ = 180¬∞ and 270¬∞) using the same formulas:

   | Point | Œ∏ (¬∞) | Position | Roll Œ± (¬∞) | Pitch Œ≤ (¬∞) | Yaw Œ≥ (¬∞) | Robot Command | Singular? |
   |-------|-------|----------|------------|-------------|-----------|---------------|-----------|
   | 0 | 0 | Top | -90 | 0 | 0 | "Roll -90¬∞" | No ‚úÖ |
   | 1 | 90 | Side (+Z) | 0 | 0 | 0 | "Home position" | No ‚úÖ |
   | 2 | 180 | Bottom | +90 | 0 | 0 | "Roll +90¬∞" | No ‚úÖ |
   | 3 | 270 | Side (-Z) | ¬±180 | 0 | 0 | "Roll ¬±180¬∞" | No ‚úÖ |

   **The beautiful insight:**
   - **Only roll (Œ±) changes** - pitch and yaw stay zero!
   - This confirms our physical intuition: we're just rotating around the pipe (X-axis)
   - Œ∏ = 90¬∞ is our "home/reference" position (identity matrix)
   - Moving clockwise from Œ∏ = 90¬∞: roll angle = -(Œ∏ - 90¬∞)
   - No complex 3D orientation calculations needed during welding!

</Steps>

</details>

### Step 4: Verification - Torch Perpendicularity Check

<details>
<summary>**Click to reveal verification calculations**</summary>

<Steps>

1. **Verification method:**

   For each waypoint, verify that the torch Z-axis (third column of rotation matrix) equals the surface normal.

2. **Waypoint Œ∏ = 0¬∞ (top of pipe):**

   **Expected:** Surface normal $\hat{n}(0¬∞) = (0, 1, 0)$ (pointing up)

   **From rotation matrix:** $R_{tool}(0¬∞) = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 0 & 1 \\ 0 & -1 & 0 \end{bmatrix}$, third column $= (0, 1, 0)$ ‚úÖ

   **Torch perpendicularity:** $\hat{n}(0¬∞) \cdot \mathbf{z}_{tool} = (0,1,0) \cdot (0,1,0) = 1.0$ ‚úÖ (perfect alignment)

3. **Waypoint Œ∏ = 90¬∞ (side toward you):**

   **Expected:** Surface normal $\hat{n}(90¬∞) = (0, 0, 1)$ (pointing toward you)

   **From rotation matrix:** $R_{tool}(90¬∞) = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix}$, third column $= (0, 0, 1)$ ‚úÖ

   **Torch perpendicularity:** $\hat{n}(90¬∞) \cdot \mathbf{z}_{tool} = (0,0,1) \cdot (0,0,1) = 1.0$ ‚úÖ (perfect alignment)

4. **All waypoints verification summary:**

   | Œ∏ (¬∞) | Surface Normal | Torch Z-axis | Dot Product | Perpendicular? |
   |-------|----------------|--------------|-------------|----------------|
   | 0 | (0, 1, 0) | (0, 1, 0) | 1.0 | ‚úÖ Yes |
   | 90 | (0, 0, 1) | (0, 0, 1) | 1.0 | ‚úÖ Yes |
   | 180 | (0, -1, 0) | (0, -1, 0) | 1.0 | ‚úÖ Yes |
   | 270 | (0, 0, -1) | (0, 0, -1) | 1.0 | ‚úÖ Yes |

</Steps>

:::note[Engineering Insight]
This simplified application demonstrates **systematic 3D orientation control** for welding robotics:

1. **Horizontal pipe geometry** makes calculations straightforward - surface normals lie in the YZ-plane
2. **Rotation matrices** are simple X-axis rotations, making them easy to construct and interpret
3. **Euler angle extraction** yields pure roll rotations - no gimbal lock possible (Œ≤ = Œ≥ = 0)
4. **No singularities** because pitch remains zero throughout the entire weld path
5. **Pattern recognition** helps understand the geometry: rolling the torch about the pipe axis

**Practical Advantage:** This simplified geometry serves as an excellent introduction to robot welding path planning. Real industrial applications build on these concepts with inclined pipes, complex joint geometries, and optimized weld speed profiles.

**Next step:** Students can extend this to inclined pipes or elliptical cross-sections to see how complexity increases!
:::

</details>

## üè≠ Application 2: Drone Camera Gimbal Stabilization (Aerial Photography)

A 2-axis camera gimbal must compensate for drone tilting to keep the camera pointing straight down at the ground.

:::note[System Problem Statement]
- **Configuration:** 2-axis gimbal (roll, pitch) mounted on quadcopter drone
- **Drone tilt:** Drone is tilted with roll = 10¬∞ and pitch = 20¬∞ (from wind or forward flight)
- **Task:** Calculate gimbal compensation angles to keep camera pointing straight down
<div style={{ display: 'flex', justifyContent: 'center', width: '100%' }}>
  <TailwindWrapper>
	![Drone Gimbal Stabilization](https://pub-b1eb899abc464b5baf5b9521d163efd9.r2.dev/spatial-mechanics/Wiris-drone-camera-gimbal.webp)
  </TailwindWrapper>
</div>
**What we need to calculate:**
1. **Drone orientation matrix** from Euler angles (roll and pitch only, no yaw)
2. **Desired camera orientation** (pointing straight down in -Y direction)
3. **Gimbal compensation matrix** $R_{gimbal} = R_{drone}^{-1} \cdot R_{desired}$
4. **Gimbal Euler angles** (roll and pitch) extracted from compensation matrix
5. **Verification** that camera points straight down after compensation

**Key Question:** How do we use rotation matrix inversion to calculate gimbal stabilization commands that cancel out drone motion?
:::

<Card title="üîß Equivalent System Model" icon="document">
<div style={{ display: 'flex', justifyContent: 'center', width: '100%' }}>
  <TailwindWrapper>
	![Gimbal Coordinate Frames](https://pub-b1eb899abc464b5baf5b9521d163efd9.r2.dev/spatial-mechanics/gimbal-frames.png)
  </TailwindWrapper>
</div>
**Given:**
- **Drone attitude:** Roll œÜ = 10¬∞, Pitch Œ∏ = 20¬∞, Yaw œà = 0¬∞ (ignore yaw for simplicity)
- **Camera desired orientation:** Pointing straight down (-Y direction)
- **Coordinate system:** X = forward, Y = up, Z = right
- **Gimbal convention:** Roll about X-axis, then Pitch about Y-axis
</Card>

### Step 1: Drone Orientation Matrix from Euler Angles

<details>
<summary>**Click to reveal drone orientation calculations**</summary>

<Steps>

1. **Understanding the problem:**

   **The situation:**
   - The drone body is tilted from level flight
   - Roll œÜ = 10¬∞ (drone is banking to the right)
   - Pitch Œ∏ = 20¬∞ (drone nose is pitched up)
   - We need to describe this tilt using a rotation matrix

   **What we're calculating:**
   - A 3√ó3 matrix that describes how the drone is oriented relative to the ground
   - This matrix will help us figure out how to compensate with the gimbal

2. **Rotation sequence explanation:**

   We apply rotations in this order:
   1. **First: Roll** about X-axis by œÜ = 10¬∞
   2. **Second: Pitch** about Y-axis by Œ∏ = 20¬∞
   3. (Yaw is 0¬∞ so we skip it)

   **Combined formula:**
   $$R_{drone} = R_y(\theta) \cdot R_x(\phi) = R_y(20¬∞) \cdot R_x(10¬∞)$$

3. **Step-by-step: Roll rotation matrix (X-axis, œÜ = 10¬∞):**

   **Formula for X-axis rotation:**
   $$R_x(\phi) = \begin{bmatrix} 1 & 0 & 0 \\ 0 & \cos\phi & -\sin\phi \\ 0 & \sin\phi & \cos\phi \end{bmatrix}$$

   **Substitute œÜ = 10¬∞:**
   - $\cos(10¬∞) = 0.9848$
   - $\sin(10¬∞) = 0.1736$

   $$R_x(10¬∞) = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 0.9848 & -0.1736 \\ 0 & 0.1736 & 0.9848 \end{bmatrix}$$ ‚úÖ

   **Physical meaning:** Rotating 10¬∞ about X-axis (banking right) - like tilting your head to the right.

4. **Step-by-step: Pitch rotation matrix (Y-axis, Œ∏ = 20¬∞):**

   **Formula for Y-axis rotation:**
   $$R_y(\theta) = \begin{bmatrix} \cos\theta & 0 & \sin\theta \\ 0 & 1 & 0 \\ -\sin\theta & 0 & \cos\theta \end{bmatrix}$$

   **Substitute Œ∏ = 20¬∞:**
   - $\cos(20¬∞) = 0.9397$
   - $\sin(20¬∞) = 0.3420$

   $$R_y(20¬∞) = \begin{bmatrix} 0.9397 & 0 & 0.3420 \\ 0 & 1 & 0 \\ -0.3420 & 0 & 0.9397 \end{bmatrix}$$ ‚úÖ

   **Physical meaning:** Rotating 20¬∞ about Y-axis (pitching up) - like nodding your head upward.

5. **Combining the rotations (matrix multiplication):**

   $$R_{drone} = R_y(20¬∞) \cdot R_x(10¬∞)$$

   $$= \begin{bmatrix} 0.9397 & 0 & 0.3420 \\ 0 & 1 & 0 \\ -0.3420 & 0 & 0.9397 \end{bmatrix} \begin{bmatrix} 1 & 0 & 0 \\ 0 & 0.9848 & -0.1736 \\ 0 & 0.1736 & 0.9848 \end{bmatrix}$$

   **Matrix multiplication (showing key elements):**

   **Element (1,1):** $0.9397(1) + 0(0) + 0.3420(0) = 0.9397$

   **Element (1,2):** $0.9397(0) + 0(0.9848) + 0.3420(0.1736) = 0.0594$

   **Element (1,3):** $0.9397(0) + 0(-0.1736) + 0.3420(0.9848) = 0.3368$

   **Element (2,1):** $0(1) + 1(0) + 0(0) = 0$

   **Element (2,2):** $0(0) + 1(0.9848) + 0(0.1736) = 0.9848$

   **Element (2,3):** $0(0) + 1(-0.1736) + 0(0.9848) = -0.1736$

   **Element (3,1):** $-0.3420(1) + 0(0) + 0.9397(0) = -0.3420$

   **Element (3,2):** $-0.3420(0) + 0(0.9848) + 0.9397(0.1736) = 0.1631$

   **Element (3,3):** $-0.3420(0) + 0(-0.1736) + 0.9397(0.9848) = 0.9254$

   **Result:**
   $$R_{drone} = \begin{bmatrix} 0.9397 & 0.0594 & 0.3368 \\ 0 & 0.9848 & -0.1736 \\ -0.3420 & 0.1631 & 0.9254 \end{bmatrix}$$ ‚úÖ

6. **What does this matrix tell us?**

   Each **column** of the matrix tells us where the drone's axes point:
   - **Column 1 (X-axis):** Where the drone's "forward" direction points
   - **Column 2 (Y-axis):** Where the drone's "up" direction points
   - **Column 3 (Z-axis):** Where the drone's "right" direction points

   The drone's "up" direction (column 2) is (0.0594, 0.9848, 0.1631) - mostly still pointing up (Y=0.9848), but tilted slightly forward and to the side.

</Steps>

</details>

### Step 2: Desired Camera Orientation Matrix

<details>
<summary>**Click to reveal desired orientation calculations**</summary>

<Steps>

1. **What do we want the camera to do?**

   **The goal:**
   - Camera should point **straight down** toward the ground
   - This means the camera's "down" direction should align with the world's "down" direction (-Y)
   - The camera should be **level** (not tilted/rolled)

   **In our coordinate system:**
   - World "down" = -Y direction = (0, -1, 0)
   - Camera optical axis points along its own Z-axis
   - So we want camera Z-axis = (0, -1, 0)

2. **What is the desired orientation matrix?**

   When the camera points straight down with no rotation:
   - Camera X-axis (forward) points along world X-axis: (1, 0, 0)
   - Camera Y-axis (up on camera) points along world Z-axis: (0, 0, 1)
   - Camera Z-axis (optical axis) points down: (0, -1, 0)

   **Building the matrix from these column vectors:**
   $$R_{desired} = [\mathbf{x}_{cam} | \mathbf{y}_{cam} | \mathbf{z}_{cam}] = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 0 & -1 \\ 0 & 1 & 0 \end{bmatrix}$$ ‚úÖ

3. **Verification - does the camera point down?**

   Apply the rotation to the camera's Z-axis unit vector (0, 0, 1):

   $$
   \mathbf{z}_{world} = R_{desired} \cdot \begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix} = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 0 & -1 \\ 0 & 1 & 0 \end{bmatrix} \begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix} = \begin{bmatrix} 0 \\ -1 \\ 0 \end{bmatrix}
   $$ 

   **Result:** (0, -1, 0) means the camera points straight down in the -Y direction! ‚úÖ

4. **Physical meaning:**

   This matrix represents a **90¬∞ rotation about the X-axis**:
   - Imagine starting with the camera pointing forward
   - Rotate it 90¬∞ down (nose down) about the X-axis
   - Now it points straight at the ground

</Steps>

</details>

### Step 3: Gimbal Compensation Calculation

<details>
<summary>**Click to reveal gimbal compensation calculations**</summary>

<Steps>

1. **Understanding the problem:**

   **The relationship:**
   - The camera is mounted on the gimbal
   - The gimbal is mounted on the drone
   - Camera orientation in world = (Drone orientation) √ó (Gimbal orientation)

   **Mathematically:**
   $$R_{camera} = R_{drone} \cdot R_{gimbal}$$

   **What we know:**
   - $R_{drone}$ = how the drone is tilted (calculated in Step 1)
   - $R_{camera} = R_{desired}$ = we want camera pointing straight down (from Step 2)
   - $R_{gimbal}$ = **this is what we need to find!**

2. **Solving for the gimbal orientation:**

   From: $R_{camera} = R_{drone} \cdot R_{gimbal}$

   We can solve for $R_{gimbal}$ by multiplying both sides by $R_{drone}^{-1}$ (the inverse):

   $$R_{gimbal} = R_{drone}^{-1} \cdot R_{camera}$$

   $$R_{gimbal} = R_{drone}^{-1} \cdot R_{desired}$$

   **Key trick:** For rotation matrices, the inverse equals the transpose!
   $$R_{drone}^{-1} = R_{drone}^T$$

3. **Calculate the drone's inverse (transpose):**

   From Step 1, we had:
   $$R_{drone} = \begin{bmatrix} 0.9397 & 0.0594 & 0.3368 \\ 0 & 0.9848 & -0.1736 \\ -0.3420 & 0.1631 & 0.9254 \end{bmatrix}$$

   **Transpose (swap rows and columns):**
   $$R_{drone}^{-1} = R_{drone}^T = \begin{bmatrix} 0.9397 & 0 & -0.3420 \\ 0.0594 & 0.9848 & 0.1631 \\ 0.3368 & -0.1736 & 0.9254 \end{bmatrix}$$ ‚úÖ

4. **Calculate gimbal compensation matrix:**

   $$R_{gimbal} = R_{drone}^{-1} \cdot R_{desired}$$

   $$= \begin{bmatrix} 0.9397 & 0 & -0.3420 \\ 0.0594 & 0.9848 & 0.1631 \\ 0.3368 & -0.1736 & 0.9254 \end{bmatrix} \begin{bmatrix} 1 & 0 & 0 \\ 0 & 0 & -1 \\ 0 & 1 & 0 \end{bmatrix}$$

   **Matrix multiplication (showing all 9 elements):**

   **Row 1:**
   - (1,1): $0.9397(1) + 0(0) + (-0.3420)(0) = 0.9397$
   - (1,2): $0.9397(0) + 0(0) + (-0.3420)(1) = -0.3420$
   - (1,3): $0.9397(0) + 0(-1) + (-0.3420)(0) = 0$

   **Row 2:**
   - (2,1): $0.0594(1) + 0.9848(0) + 0.1631(0) = 0.0594$
   - (2,2): $0.0594(0) + 0.9848(0) + 0.1631(1) = 0.1631$
   - (2,3): $0.0594(0) + 0.9848(-1) + 0.1631(0) = -0.9848$

   **Row 3:**
   - (3,1): $0.3368(1) + (-0.1736)(0) + 0.9254(0) = 0.3368$
   - (3,2): $0.3368(0) + (-0.1736)(0) + 0.9254(1) = 0.9254$
   - (3,3): $0.3368(0) + (-0.1736)(-1) + 0.9254(0) = 0.1736$

   **Result:**
   $$R_{gimbal} = \begin{bmatrix} 0.9397 & -0.3420 & 0 \\ 0.0594 & 0.1631 & -0.9848 \\ 0.3368 & 0.9254 & 0.1736 \end{bmatrix}$$ ‚úÖ

5. **What does this mean?**

   This matrix tells the gimbal: "To cancel out the drone's tilt and point the camera straight down, you need to rotate in the opposite direction of the drone's tilt."

</Steps>

</details>

### Step 4: Extract Gimbal Euler Angles (Roll and Pitch)

<details>
<summary>**Click to reveal Euler angle extraction**</summary>

<Steps>

1. **Why extract Euler angles?**

   - The gimbal motors need simple angle commands: "rotate roll by X¬∞, pitch by Y¬∞"
   - We have a 3√ó3 matrix, but need to extract the roll and pitch angles from it
   - This is the reverse of what we did in Step 1

2. **Euler angle extraction formulas:**

   Given rotation matrix $R = \begin{bmatrix} r_{11} & r_{12} & r_{13} \\ r_{21} & r_{22} & r_{23} \\ r_{31} & r_{32} & r_{33} \end{bmatrix}$:

   - **Pitch (Œ∏):** $\theta = \arcsin(-r_{31})$
   - **Roll (œÜ):** $\phi = \arctan2(r_{32}, r_{33})$

   **Our gimbal matrix:**
   $$R_{gimbal} = \begin{bmatrix} 0.9397 & -0.3420 & 0 \\ 0.0594 & 0.1631 & -0.9848 \\ 0.3368 & 0.9254 & 0.1736 \end{bmatrix}$$

3. **Calculate pitch:**

   $$\theta_{pitch} = \arcsin(-r_{31}) = \arcsin(-0.3368)$$

   $$= -19.68¬∞ \approx -20¬∞$$ ‚úÖ

   **Physical meaning:** Gimbal needs to pitch down by 20¬∞ to compensate for drone pitching up by 20¬∞!

4. **Why Euler angle extraction is tricky here:**

   Extracting Euler angles from the gimbal compensation matrix is more complex than it might seem for a 2-axis gimbal. The matrix we calculated represents the combined compensation needed, but extracting meaningful roll and pitch angles depends on the specific rotation sequence the gimbal hardware uses.

   **The key insight:**
   - The gimbal needs to rotate opposite to the drone's motion
   - Drone rolled 10¬∞ right ‚Üí gimbal should roll ~10¬∞ left
   - Drone pitched 20¬∞ up ‚Üí gimbal should pitch ~20¬∞ down

5. **Better approach: Direct verification**

   Instead of extracting Euler angles, let's verify directly that the camera points down after compensation (Step 5).

</Steps>

</details>

### Step 5: Verification - Does the Camera Point Straight Down?

<details>
<summary>**Click to reveal verification calculations**</summary>

<Steps>

1. **The test: Does the final camera point straight down?**

   We need to verify: $R_{camera} = R_{drone} \cdot R_{gimbal} = R_{desired}$

   **What we'll check:**
   - Apply the gimbal compensation to the tilted drone
   - See where the camera's Z-axis (optical axis) ends up pointing
   - It should point straight down: (0, -1, 0)

2. **Calculate final camera orientation:**

   $$R_{camera} = R_{drone} \cdot R_{gimbal}$$

   $$= \begin{bmatrix} 0.9397 & 0.0594 & 0.3368 \\ 0 & 0.9848 & -0.1736 \\ -0.3420 & 0.1631 & 0.9254 \end{bmatrix} \begin{bmatrix} 0.9397 & -0.3420 & 0 \\ 0.0594 & 0.1631 & -0.9848 \\ 0.3368 & 0.9254 & 0.1736 \end{bmatrix}$$

   **We only need to check where the camera Z-axis points (third column of result):**

   Camera Z-axis = $R_{camera} \cdot \begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix}$ = (third column of $R_{camera}$)

   **Element (1,3):** $0.9397(0) + 0.0594(-0.9848) + 0.3368(0.1736)$
   $$= 0 - 0.0585 + 0.0585 = 0.0000 \approx 0$$ ‚úÖ

   **Element (2,3):** $0(0) + 0.9848(-0.9848) + (-0.1736)(0.1736)$
   $$= 0 - 0.9698 - 0.0301 = -1.0000 \approx -1$$ ‚úÖ

   **Element (3,3):** $-0.3420(0) + 0.1631(-0.9848) + 0.9254(0.1736)$
   $$= 0 - 0.1607 + 0.1607 = 0.0000 \approx 0$$ ‚úÖ

   **Result:** Camera Z-axis points to $(0, -1, 0)$ = straight down! ‚úÖ

3. **Success!**

   The gimbal compensation works perfectly:
   - Drone is tilted (roll = 10¬∞, pitch = 20¬∞)
   - Gimbal compensates with opposite rotations
   - Camera ends up pointing straight down at the ground

</Steps>

:::note[Engineering Insight]
This simplified application demonstrates **gimbal stabilization** fundamentals:

1. **Matrix composition:** $R_{camera} = R_{drone} \cdot R_{gimbal}$ represents how orientations combine
2. **Matrix inversion:** $R_{gimbal} = R_{drone}^{-1} \cdot R_{desired}$ solves for compensation
3. **Transpose trick:** For rotation matrices, $R^{-1} = R^T$ (just swap rows/columns!)
4. **Simpler problem:** Using roll = 10¬∞ and pitch = 20¬∞ with camera pointing straight down makes calculations more intuitive

**Practical Application:** Real drone gimbals update at 200-400Hz using microcontrollers. The matrix operations (9 multiplications + 6 additions for transpose, plus ~27 more for multiplication) can execute in less than 1ms on modern ARM processors.

**Next step:** Students can extend this to 3-axis gimbals with yaw control, or add constraints like "keep horizon level in frame" for cinematography applications!
:::

</details>

## üè≠ Application 3: Satellite Attitude Control for Solar Tracking (Space Systems)

A satellite needs to reorient its solar panels to point toward the sun using reaction wheel actuation.

:::note[System Problem Statement]
- **Configuration:** Spacecraft with 3-axis attitude control using reaction wheels
- **Objective:** Rotate solar panel normal from current orientation to point at sun
- **Task:** Calculate required spacecraft rotation using arbitrary axis rotation (Rodrigues formula)
<div style={{ display: 'flex', justifyContent: 'center', width: '100%' }}>
  <TailwindWrapper>
	![Satellite Attitude Control](https://pub-b1eb899abc464b5baf5b9521d163efd9.r2.dev/spatial-mechanics/satellite-attitude.png)
  </TailwindWrapper>
</div>
**What we need to calculate:**
1. **Sun vector** in spacecraft body frame
2. **Rotation axis** (perpendicular to current and desired panel orientations)
3. **Rotation angle** (how much to rotate)
4. **Rotation matrix** using Rodrigues formula
5. **Verification** that panel normal aligns with sun vector

**Key Question:** How do we use arbitrary axis rotation to reorient the spacecraft solar panels toward the sun?
:::

<Card title="üîß Equivalent System Model" icon="document">
<div style={{ display: 'flex', justifyContent: 'center', width: '100%' }}>
  <TailwindWrapper>
	![Satellite Geometry](https://pub-b1eb899abc464b5baf5b9521d163efd9.r2.dev/spatial-mechanics/satellite-geometry.png)
  </TailwindWrapper>
</div>
**Given:**
- **Spacecraft body frame:** X = velocity direction, Y = radial (toward Earth), Z = orbit normal
- **Solar panel normal (current):** Along +Z body axis = [0, 0, 1]
- **Sun direction (in body frame):** [0.6, 0, 0.8] (normalized)
- **Solar panel area:** 2.5 m¬≤, efficiency 30%
- **Task:** Find rotation matrix R that aligns panel normal with sun direction

**What makes this interesting:**
- We cannot decompose this into simple X, Y, Z rotations easily
- Instead, we use **Rodrigues formula** for arbitrary axis rotation
- This is how real spacecraft attitude control systems work
</Card>

### Step 1: Identify Current and Desired Panel Orientations

<details>
<summary>**Click to reveal vector setup**</summary>

<Steps>

1. **Current solar panel normal (before rotation):**

   The solar panel is mounted on the spacecraft with its normal vector pointing along the +Z body axis.

   $$\mathbf{n}_{current} = \begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix}$$

   **Physical interpretation:** Panel faces "up" relative to orbit plane.

2. **Sun direction in body frame:**

   At this moment in the orbit, sensors measure the sun direction in the spacecraft body frame:

   $$\mathbf{s}_{sun} = \begin{bmatrix} 0.6 \\ 0 \\ 0.8 \end{bmatrix}$$

   **Verify this is a unit vector:**
   $$|\mathbf{s}_{sun}| = \sqrt{0.6^2 + 0^2 + 0.8^2} = \sqrt{0.36 + 0 + 0.64} = \sqrt{1.0} = 1.0$$ ‚úÖ

   **Physical interpretation:** Sun is in the XZ-plane (no Y-component), pointing mostly forward (+X) and somewhat "up" (+Z).

3. **Desired panel normal (after rotation):**

   To maximize solar power, we want the panel normal to point directly at the sun:

   $$\mathbf{n}_{desired} = \mathbf{s}_{sun} = \begin{bmatrix} 0.6 \\ 0 \\ 0.8 \end{bmatrix}$$

4. **Visualization of the rotation problem:**

   | Vector | Direction | Coordinates |
   |--------|-----------|-------------|
   | Current normal | Along +Z axis | [0, 0, 1] |
   | Sun direction | In XZ-plane | [0.6, 0, 0.8] |
   | Need to rotate | From current to sun | ? |

   **Key observation:** Both vectors lie in the XZ-plane (Y-component is zero for both), so the rotation axis must be perpendicular to the XZ-plane (i.e., along Y-axis or close to it).

</Steps>

</details>

### Step 2: Calculate Rotation Axis and Angle

<details>
<summary>**Click to reveal rotation axis and angle calculations**</summary>

<Steps>

1. **Find the rotation axis using cross product:**

   The rotation axis must be perpendicular to both the current panel normal and the desired (sun) direction. We use the cross product:

   $$\mathbf{v} = \mathbf{n}_{current} \times \mathbf{n}_{desired}$$

   $$= \begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix} \times \begin{bmatrix} 0.6 \\ 0 \\ 0.8 \end{bmatrix}$$

   **Cross product formula reminder:**
   $$\mathbf{a} \times \mathbf{b} = \begin{bmatrix} a_y b_z - a_z b_y \\ a_z b_x - a_x b_z \\ a_x b_y - a_y b_x \end{bmatrix}$$

   **Apply the formula:**
   - X-component: $(0)(0.8) - (1)(0) = 0$
   - Y-component: $(1)(0.6) - (0)(0.8) = 0.6$
   - Z-component: $(0)(0) - (0)(0.6) = 0$

   $$\mathbf{v} = \begin{bmatrix} 0 \\ 0.6 \\ 0 \end{bmatrix}$$

   **Physical interpretation:** Rotation axis points along +Y (toward Earth). This makes sense since both the current normal and sun direction are in the XZ-plane.

2. **Normalize to get unit rotation axis:**

   $$|\mathbf{v}| = \sqrt{0^2 + 0.6^2 + 0^2} = 0.6$$

   $$\hat{\mathbf{v}} = \frac{\mathbf{v}}{|\mathbf{v}|} = \frac{1}{0.6} \begin{bmatrix} 0 \\ 0.6 \\ 0 \end{bmatrix} = \begin{bmatrix} 0 \\ 1 \\ 0 \end{bmatrix}$$

   **Result:** Unit rotation axis is exactly the +Y body axis.

3. **Calculate rotation angle using dot product:**

   $$\cos\phi = \mathbf{n}_{current} \cdot \mathbf{n}_{desired}$$

   $$= (0)(0.6) + (0)(0) + (1)(0.8) = 0.8$$

   $$\phi = \arccos(0.8) = 36.87¬∞$$

4. **Verify using cross product magnitude:**

   For unit vectors: $|\mathbf{a} \times \mathbf{b}| = |\mathbf{a}| |\mathbf{b}| \sin\phi$

   $$|\mathbf{v}| = (1)(1) \sin\phi = \sin\phi$$

   $$\sin\phi = 0.6$$

   $$\phi = \arcsin(0.6) = 36.87¬∞$$ ‚úÖ

   **Check trigonometric identity:** $\sin^2\phi + \cos^2\phi = 0.6^2 + 0.8^2 = 0.36 + 0.64 = 1.0$ ‚úÖ

5. **Summary of rotation parameters:**

   | Parameter | Value | Physical Meaning |
   |-----------|-------|------------------|
   | Rotation axis | [0, 1, 0] | Along +Y (toward Earth) |
   | Rotation angle | 36.87¬∞ | Tilt panel forward toward sun |
   | Rotation direction | Right-hand rule | Thumb along +Y, fingers curl from +Z toward +X |

</Steps>

</details>

### Step 3: Build Rotation Matrix Using Rodrigues Formula

<details>
<summary>**Click to reveal Rodrigues rotation matrix construction**</summary>

<Steps>

1. **Rodrigues rotation formula:**

   For a rotation by angle œÜ about unit axis $\hat{\mathbf{v}}$:

   $$R(\hat{\mathbf{v}}, \phi) = I + (\sin\phi) W + (1 - \cos\phi) W^2$$

   Where:
   - $I$ = 3√ó3 identity matrix
   - $W$ = skew-symmetric matrix of $\hat{\mathbf{v}}$
   - $\phi$ = rotation angle

   **Why this works:** Rodrigues formula gives the same result as rotating a vector around an arbitrary axis, derived from exponential map of rotation.

2. **Construct skew-symmetric matrix W:**

   For rotation axis $\hat{\mathbf{v}} = [0, 1, 0]^T$:

   $$W = \begin{bmatrix} 0 & -v_z & v_y \\ v_z & 0 & -v_x \\ -v_y & v_x & 0 \end{bmatrix} = \begin{bmatrix} 0 & 0 & 1 \\ 0 & 0 & 0 \\ -1 & 0 & 0 \end{bmatrix}$$

   **Physical meaning:** The skew-symmetric matrix $W$ represents the cross product operation with $\hat{\mathbf{v}}$.

3. **Calculate $W^2$:**

   $$W^2 = \begin{bmatrix} 0 & 0 & 1 \\ 0 & 0 & 0 \\ -1 & 0 & 0 \end{bmatrix} \cdot \begin{bmatrix} 0 & 0 & 1 \\ 0 & 0 & 0 \\ -1 & 0 & 0 \end{bmatrix}$$

   **Element-by-element multiplication:**
   - Row 1, Col 1: $(0)(0) + (0)(0) + (1)(-1) = -1$
   - Row 1, Col 2: $(0)(0) + (0)(0) + (1)(0) = 0$
   - Row 1, Col 3: $(0)(1) + (0)(0) + (1)(0) = 0$
   - Row 2, Col 1: $(0)(0) + (0)(0) + (0)(-1) = 0$
   - Row 2, Col 2: $(0)(0) + (0)(0) + (0)(0) = 0$
   - Row 2, Col 3: $(0)(1) + (0)(0) + (0)(0) = 0$
   - Row 3, Col 1: $(-1)(0) + (0)(0) + (0)(-1) = 0$
   - Row 3, Col 2: $(-1)(0) + (0)(0) + (0)(0) = 0$
   - Row 3, Col 3: $(-1)(1) + (0)(0) + (0)(0) = -1$

   $$W^2 = \begin{bmatrix} -1 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & -1 \end{bmatrix}$$

4. **Apply Rodrigues formula with œÜ = 36.87¬∞:**

   $$\sin(36.87¬∞) = 0.6, \quad \cos(36.87¬∞) = 0.8$$
   $$1 - \cos(36.87¬∞) = 1 - 0.8 = 0.2$$

   $$R = I + 0.6 \cdot W + 0.2 \cdot W^2$$

   $$= \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix} + 0.6 \begin{bmatrix} 0 & 0 & 1 \\ 0 & 0 & 0 \\ -1 & 0 & 0 \end{bmatrix} + 0.2 \begin{bmatrix} -1 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & -1 \end{bmatrix}$$

   $$= \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \end{bmatrix} + \begin{bmatrix} 0 & 0 & 0.6 \\ 0 & 0 & 0 \\ -0.6 & 0 & 0 \end{bmatrix} + \begin{bmatrix} -0.2 & 0 & 0 \\ 0 & 0 & 0 \\ 0 & 0 & -0.2 \end{bmatrix}$$

   **Add element-by-element:**
   $$R = \begin{bmatrix} 1 + 0 - 0.2 & 0 + 0 + 0 & 0 + 0.6 + 0 \\ 0 + 0 + 0 & 1 + 0 + 0 & 0 + 0 + 0 \\ 0 - 0.6 + 0 & 0 + 0 + 0 & 1 + 0 - 0.2 \end{bmatrix}$$

   $$R = \begin{bmatrix} 0.8 & 0 & 0.6 \\ 0 & 1 & 0 \\ -0.6 & 0 & 0.8 \end{bmatrix}$$ ‚úÖ

5. **Physical interpretation of the rotation matrix:**

   This is a rotation about the Y-axis by 36.87¬∞. Notice:
   - Middle row/column unchanged: [0, 1, 0] (Y-axis is rotation axis)
   - X and Z components mix according to rotation angle
   - This is exactly $R_y(36.87¬∞)$ from standard rotation matrix formulas

   **Comparison to standard Y-axis rotation:**
   $$R_y(\theta) = \begin{bmatrix} \cos\theta & 0 & \sin\theta \\ 0 & 1 & 0 \\ -\sin\theta & 0 & \cos\theta \end{bmatrix} = \begin{bmatrix} 0.8 & 0 & 0.6 \\ 0 & 1 & 0 \\ -0.6 & 0 & 0.8 \end{bmatrix}$$ ‚úÖ

   **Key insight:** For this problem, Rodrigues formula gives us the same result as a simple Y-axis rotation. But Rodrigues formula works for ANY arbitrary axis, not just X, Y, or Z!

</Steps>

</details>

### Step 4: Verify the Rotation Works

<details>
<summary>**Click to reveal verification**</summary>

<Steps>

1. **Apply rotation to current panel normal:**

   $$\mathbf{n}_{final} = R \cdot \mathbf{n}_{current}$$

   $$= \begin{bmatrix} 0.8 & 0 & 0.6 \\ 0 & 1 & 0 \\ -0.6 & 0 & 0.8 \end{bmatrix} \begin{bmatrix} 0 \\ 0 \\ 1 \end{bmatrix}$$

   **Matrix-vector multiplication:**
   - X-component: $(0.8)(0) + (0)(0) + (0.6)(1) = 0.6$
   - Y-component: $(0)(0) + (1)(0) + (0)(1) = 0$
   - Z-component: $(-0.6)(0) + (0)(0) + (0.8)(1) = 0.8$

   $$\mathbf{n}_{final} = \begin{bmatrix} 0.6 \\ 0 \\ 0.8 \end{bmatrix}$$

2. **Compare to desired (sun direction):**

   **Desired:** $\mathbf{n}_{desired} = [0.6, 0, 0.8]^T$

   **Actual:** $\mathbf{n}_{final} = [0.6, 0, 0.8]^T$

   **Perfect match!** ‚úÖ

3. **Calculate solar power output:**

   Solar panels generate maximum power when perpendicular to sunlight. Power follows cosine law:

   $$P = P_{max} \cdot (\mathbf{n}_{final} \cdot \mathbf{s}_{sun})$$

   **Dot product (alignment factor):**
   $$\mathbf{n}_{final} \cdot \mathbf{s}_{sun} = (0.6)(0.6) + (0)(0) + (0.8)(0.8) = 0.36 + 0 + 0.64 = 1.0$$

   **Maximum possible power:**
   $$P_{max} = \text{Area} \times \text{Solar constant} \times \text{Efficiency}$$
   $$= 2.5 \, \text{m}^2 \times 1367 \, \text{W/m}^2 \times 0.30 = 1025.25 \, \text{W}$$

   **Actual power (perfect alignment):**
   $$P = 1025.25 \times 1.0 = 1025.25 \, \text{W}$$ ‚úÖ

   This is maximum possible power from these solar panels!

4. **Summary:**

   | Parameter | Value | Status |
   |-----------|-------|--------|
   | Rotation axis | [0, 1, 0] (Y-axis) | ‚úÖ |
   | Rotation angle | 36.87¬∞ | ‚úÖ |
   | Panel alignment | Perfect (error = 0) | ‚úÖ |
   | Solar power | 1025 W | ‚úÖ Maximum |
   | Method | Rodrigues formula | ‚úÖ |

</Steps>

:::note[Engineering Insight]
This application demonstrates **arbitrary axis rotation** for spacecraft attitude control:

1. **Cross product** determines the rotation axis perpendicular to both current and desired orientations
2. **Rodrigues formula** provides an elegant rotation matrix without needing Euler angle decomposition
3. **No gimbal lock** is possible with arbitrary axis rotation (works for all orientations)
4. **Clean mathematics** when rotation axis aligns with a coordinate axis (as in this example)

**Practical implementation:** Real satellite attitude determination and control systems (ADCS) use **quaternions** for onboard computation (more efficient than matrices and no gimbal lock), but ground station analysis uses rotation matrices for human interpretability. Rodrigues formula bridges both representations.

**Real-world consideration:** Continuous sun tracking creates **cyclic angular momentum** in reaction wheels. Periodic **momentum dumping** using magnetic torquers or thrusters is required every few orbits to prevent wheel saturation. This is why satellites need both reaction wheels (for precision) and magnetic torquers (for momentum management).
:::

</details>

## üìã Summary and Next Steps

In this lesson, you learned 3D rotation and transformation mathematics through theory and applications.

**Key Skills Developed:**
1. **Construct** rotation matrices for X, Y, Z coordinate axes using trigonometric relationships
2. **Apply** Euler angle sequences (ZYX, ZYZ) while managing singularities and gimbal lock
3. **Calculate** arbitrary axis rotations using decomposition method or Rodrigues formula
4. **Compose** 4√ó4 homogeneous transformation matrices for unified rotation and translation

**Two Methods for Arbitrary Axis Rotations:**
- **Decomposition approach:** Intuitive 5-step geometric method (best for education and analysis)
- **Rodrigues formula:** $R = I + \sin\theta \, W + (1-\cos\theta) W^2$ (best for implementation)

**Applications Covered:**
- **Robotic welding** - Surface normals, tool orientation matrices, SLERP interpolation
- **Drone gimbal stabilization** - Matrix inversion, real-time compensation at 200Hz
- **Satellite attitude control** - Rodrigues formula for sun tracking with dual constraints

**Critical Properties:**
- <Badge text="Rotation matrices are orthogonal: R‚Åª¬π = R·µÄ" variant="tip" />
- <Badge text="Euler angles have gimbal lock at pitch = ¬±90¬∞" variant="caution" />
- <Badge text="Matrix multiplication order matters: R‚ÇÉR‚ÇÇR‚ÇÅ applies R‚ÇÅ first" variant="note" />

**Coming Next**: Lesson 4 develops systematic kinematic modeling using DH parameters for Stewart Platform analysis.

<SpatialMechanicsComments />
<TawkWidget />
<Copyright />
